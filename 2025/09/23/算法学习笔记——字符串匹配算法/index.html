<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法学习笔记——字符串匹配算法 | Alphazer01214’s Blog</title><meta name="author" content="Alpha_零能"><meta name="copyright" content="Alpha_零能"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="KMP  线性时间匹配字符串的算法。  引入：前缀函数 先明确「前缀」和「后缀」的定义：  前缀：从字符串开头开始的子串（如 abcde 的前缀有 a、ab、abc、abcd）； 后缀：以字符串结尾结束的子串（如 abcde 的后缀有 e、de、cde、bcde）； 「相等前缀和后缀」：指内容完全相同的前缀和后缀（如 abab 的前缀 ab 和后缀 ab 相等）。  则 π[i] 表示：  子串">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习笔记——字符串匹配算法">
<meta property="og:url" content="http://alphazer01214.github.io/2025/09/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Alphazer01214’s Blog">
<meta property="og:description" content="KMP  线性时间匹配字符串的算法。  引入：前缀函数 先明确「前缀」和「后缀」的定义：  前缀：从字符串开头开始的子串（如 abcde 的前缀有 a、ab、abc、abcd）； 后缀：以字符串结尾结束的子串（如 abcde 的后缀有 e、de、cde、bcde）； 「相等前缀和后缀」：指内容完全相同的前缀和后缀（如 abab 的前缀 ab 和后缀 ab 相等）。  则 π[i] 表示：  子串">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://alphazer01214.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-09-23T15:17:35.000Z">
<meta property="article:modified_time" content="2025-10-13T12:23:31.470Z">
<meta property="article:author" content="Alpha_零能">
<meta property="article:tag" content="Alphazer01214">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://alphazer01214.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://alphazer01214.github.io/2025/09/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?13749296cb241d17e3126c6062c91c75";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法学习笔记——字符串匹配算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Alphazer01214’s Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw music list"></i><span> 歌单</span></a></li><li><a class="site-page child" href="/anime/"><i class="fa-fw anime list"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/galgames/"><i class="fa-fw galgame list"></i><span> Galgame</span></a></li><li><a class="site-page child" href="/books/"><span> 书单</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Alphazer01214’s Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">算法学习笔记——字符串匹配算法</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw music list"></i><span> 歌单</span></a></li><li><a class="site-page child" href="/anime/"><i class="fa-fw anime list"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/galgames/"><i class="fa-fw galgame list"></i><span> Galgame</span></a></li><li><a class="site-page child" href="/books/"><span> 书单</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">算法学习笔记——字符串匹配算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-23T15:17:35.000Z" title="发表于 2025-09-23 23:17:35">2025-09-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-13T12:23:31.470Z" title="更新于 2025-10-13 20:23:31">2025-10-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>4分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>KMP</h1>
<blockquote>
<p>线性时间匹配字符串的算法。</p>
</blockquote>
<h2 id="引入：前缀函数">引入：前缀函数</h2>
<p>先明确「前缀」和「后缀」的定义：</p>
<ul>
<li><strong>前缀</strong>：从字符串开头开始的子串（如 <code>abcde</code> 的前缀有 <code>a</code>、<code>ab</code>、<code>abc</code>、<code>abcd</code>）；</li>
<li><strong>后缀</strong>：以字符串结尾结束的子串（如 <code>abcde</code> 的后缀有 <code>e</code>、<code>de</code>、<code>cde</code>、<code>bcde</code>）；</li>
<li>「相等前缀和后缀」：指内容完全相同的前缀和后缀（如 <code>abab</code> 的前缀 <code>ab</code> 和后缀 <code>ab</code> 相等）。</li>
</ul>
<p>则 <em>π</em>[<em>i</em>] 表示：</p>
<ul>
<li>子串 <em>s</em>[0…<em>i</em>]（即从第 0 个字符到第 <em>i</em> 个字符的子串）中，<strong>最长的、既等于该子串前缀，又等于该子串后缀的非平凡子串的长度</strong>。</li>
</ul>
<p>注意<strong>最长</strong>这一条件。</p>
<h2 id="计算前缀函数">计算前缀函数</h2>
<p>因为有“最长”这一条件限制，因此采用 DP 即可实现其最优结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;...&quot;</span></span><br><span class="line">pi[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// 没有子串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">    <span class="type">int</span> len = pi[i<span class="number">-1</span>];    <span class="comment">// s[0:i-1]最长前缀长度(作为已知量)</span></span><br><span class="line">    <span class="keyword">if</span>(s[len] == s[i])&#123;</span><br><span class="line">		<span class="comment">// 如果下一个字符相同，则+1</span></span><br><span class="line">        pi[i] = len + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果不同，那就要回退。如何回退？可以枚举len(最长前缀长度)！也就是：</span></span><br><span class="line">        <span class="comment">// 枚举x in len， s[0:x] == s[i-x-1:i-1] 并且 s[x+1] == s[i]</span></span><br><span class="line">        <span class="comment">// 画图！因为两个pi[i-1]区间内是相等的，可以得到对称性：s[0:x] == s[len-1-x:len-1]</span></span><br><span class="line">        <span class="comment">// 所以只需要令新的len = pi[x]且s[i] == s[len]即可得到pi[i]</span></span><br><span class="line">        <span class="keyword">while</span>(len &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[len])&#123;</span><br><span class="line">            len = pi[len<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%5CKMP.png" alt="KMP"></p>
<h2 id="与-next-的关系">与 next 的关系</h2>
<p><strong><code>next</code> 不是前缀函数本身，而是基于前缀函数构造的“跳转表”</strong>，用于在匹配失败时决定模式串该“回退到哪里”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pat = <span class="string">&quot;&quot;</span>;  <span class="comment">// 模式</span></span><br><span class="line">str = <span class="string">&quot;&quot;</span>; </span><br><span class="line">i = <span class="number">0</span>;     <span class="comment">// str指针</span></span><br><span class="line">j = <span class="number">-1</span>;    <span class="comment">// next 指针</span></span><br><span class="line">next = pi; <span class="comment">// 模式串前缀函数且next[0] == -1</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; str.<span class="built_in">length</span>())&#123;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">-1</span> || pat[i] == str[i])&#123;</span><br><span class="line">        ++i;++j;  <span class="comment">// 如果在开头或有匹配的，那就都右移</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        j = next[j];  <span class="comment">// 否则回退</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h1>Manacher</h1>
<blockquote>
<p>寻找最长回文子串的算法。</p>
</blockquote>
<h2 id="寻找回文子串的一般做法">寻找回文子串的一般做法</h2>
<p>枚举一个中心点，并向两侧扩展，复杂度为$O(n^2)$。</p>
<p>不仅复杂度高，而且需要奇偶分类讨论。因此需要一个更高效的算法。</p>
<h2 id="Manacher-算法">Manacher 算法</h2>
<p>有一个字符串<code>s=&quot;abcba&quot;</code>，为了使其有一个对称中心，我们可以考虑<strong>插入特殊字符</strong>使得其具有一个对称中心，也就是说 <code>s.length()</code> 从 $n$ 到 $2n+1$ 。</p>
<p><code>t = &quot;^#a#b#c#b#a#$&quot;</code> 注意 <code>^$</code> 是防止越界的。</p>
<p>考虑有一个数组 <code>P[i]</code> 表示 <code>s[i]</code> 的半径(包括自身，例如ab的半径为1，aba的半径为2)。利用动态规划的思想，假设一切 <code>P[i]</code> 都是已知的，接下来寻找递推关系。显然有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i+P[i]] == s[i-P[i]])&#123;</span><br><span class="line">    P[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时有恒等式 <code>s[i+P[i]-1] == s[i-P[i]+1]</code>。</p>
<p>但是，如果仅仅这样，复杂度仍是 $O(n^2)$ ，其关键在于 <code>P[i]</code> 从 1 开始遍历。为了降低时间复杂度，我们需要通过一些观察使得 <strong>每次计算P前，都为P初始化一个值</strong>。</p>
<p><strong>重要观察</strong> ： 在中点 C 的半径内， P[i] 的<strong>最小值的</strong>分布是对称的，也就是说 <code>P[C-k] == P[C+k]</code> 当 <code>k &lt;= P[i]</code> 且P均代表着可能的最小值。这由字符串对称性是显然的。因此，我们就可以根据这个最小值缩写枚举的范围。</p>
<p>需要注意的是，因为半径以外的内容是“不可见”的，因此<em>先初始化的部分</em> (也就是对称点前的)有可能更大(因为半径外的字符串可能有影响)，这时就要求：对P的初始化<strong>不能使得p[i] &gt; R-i</strong>也就是要使得该点为中心，半径不会超过右边界。</p>
<p>可以进行一步贪心：记录当前最大右边界 <code>R</code> 及最长回文中点 <code>C</code> 并维护之，有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i + P[i] &gt; R)&#123;</span><br><span class="line">    C = i;</span><br><span class="line">    R = i+P[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在半径内初始化P[i]：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &lt; R)&#123;</span><br><span class="line">    <span class="comment">// 如果在右边界内，那就用对称找到初始值，同时还要注意这个语句不能用来更新右边界，因此还要和 R-i 比较取小的一个</span></span><br><span class="line">    P[i] = <span class="built_in">min</span>(R-i, P[<span class="number">2</span>*C-i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例题： LeetCode 647 回文子串：给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">2333</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        string t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch: s)&#123;</span><br><span class="line">            t = t + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            t = t + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; r)&#123;</span><br><span class="line">                p[i] = <span class="built_in">min</span>(r-i, p[<span class="number">2</span>*c-i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i-p[i] &gt;= <span class="number">0</span> &amp;&amp; i+p[i] &lt; t.<span class="built_in">length</span>() &amp;&amp; t[i+p[i]] == t[i-p[i]])&#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i + p[i] &gt; r)&#123;</span><br><span class="line">                r = i+p[i];</span><br><span class="line">                c = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res += p[i] / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>Boyer-Moore</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://alphazer01214.github.io">Alpha_零能</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://alphazer01214.github.io/2025/09/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/">http://alphazer01214.github.io/2025/09/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://alphazer01214.github.io" target="_blank">Alphazer01214’s Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/13/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A0%91/" title="算法学习笔记——树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">算法学习笔记——树</div></div><div class="info-2"><div class="info-item-1">二叉查找树  一个类似二分查找的结构。核心是左&lt;中&lt;右。  构建 由一个数组建立一个二叉搜索树，首先要注意的是根节点也有数值。二叉树的定义仍遵循LeetCode的经典定义 12345678struct TreeNode &#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;; 并定义一个数组 arr...</div></div></div></a><a class="pagination-related" href="/2025/07/07/%E4%BF%AE%E5%A4%8DEdge%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E5%BC%82%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98/" title="修复Edge窗口显示异常的问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">修复Edge窗口显示异常的问题</div></div><div class="info-2"><div class="info-item-1">问题描述新买的天选6Pro，买回来第一天就感觉有点怪：刚开始是B站网页端的视频弹幕显示非常浅，观感非常奇怪；接着就是Edge浏览器出现了部分画面滞留的问题，再后来连VS Code都出现了这个问题。。。 CPU：AMD Ryzen 9 8940HX 显卡：RTX 5060 Laptop 系统：Windows 11 24H2 解决方法最后发现原因是Windows MPO功能，据说这会提升游戏性能，结果反而是Bug一堆，那要这功能有什么用。。。 在NVIDIA网站上有解决该问题的文件：After updating to NVIDIA Game Ready Driver 461.09 or newer, some desktop apps may flicker or stutter when resizing the window on some PC configurations | NVIDIA，点击下载mpo_disable.reg并运行即可。 </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Alpha_零能</div><div class="author-info-description">实用主义 | 兴趣使然</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/alphazer01214"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/alphazer01214" target="_blank" title="Alphazer01214's github"><i class="fa-brands fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:alphazer01214@gmail.com" target="_blank" title="Alphazer011214's email"><i class="fa-solid fa-square-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/9879205" target="_blank" title="Alpha_零能 Bilibili主页"><i class="fa-brands fa-bilibili" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">KMP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%EF%BC%9A%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">引入：前缀函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">计算前缀函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-next-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">与 next 的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Manacher</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E7%9A%84%E4%B8%80%E8%88%AC%E5%81%9A%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">寻找回文子串的一般做法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manacher-%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">Manacher 算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Boyer-Moore</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="算法学习笔记——动态规划">算法学习笔记——动态规划</a><time datetime="2025-10-20T12:04:39.000Z" title="发表于 2025-10-20 20:04:39">2025-10-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="算法学习笔记——基础数据结构">算法学习笔记——基础数据结构</a><time datetime="2025-10-15T09:23:50.000Z" title="发表于 2025-10-15 17:23:50">2025-10-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%BA/" title="算法学习笔记——图论">算法学习笔记——图论</a><time datetime="2025-10-15T09:22:25.000Z" title="发表于 2025-10-15 17:22:25">2025-10-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%8D%E8%BF%90%E7%AE%97/" title="算法学习笔记——位运算">算法学习笔记——位运算</a><time datetime="2025-10-14T08:06:00.000Z" title="发表于 2025-10-14 16:06:00">2025-10-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/13/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A0%91/" title="算法学习笔记——树">算法学习笔记——树</a><time datetime="2025-10-13T12:23:59.000Z" title="发表于 2025-10-13 20:23:59">2025-10-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Alpha_零能</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alphazer01214’s Blog</title>
  
  <subtitle>Alpha_零能的个人主页</subtitle>
  <link href="http://alphazer01214.github.io/atom.xml" rel="self"/>
  
  <link href="http://alphazer01214.github.io/"/>
  <updated>2025-02-02T14:40:18.461Z</updated>
  <id>http://alphazer01214.github.io/</id>
  
  <author>
    <name>Alpha_零能</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Transformer</title>
    <link href="http://alphazer01214.github.io/2025/02/02/Transformer/"/>
    <id>http://alphazer01214.github.io/2025/02/02/Transformer/</id>
    <published>2025-02-02T14:38:57.000Z</published>
    <updated>2025-02-02T14:40:18.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Transformer-的基本架构"><a href="#Transformer-的基本架构" class="headerlink" title="Transformer 的基本架构"></a>Transformer 的基本架构</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Transformer-的基本架构&quot;&gt;&lt;a href=&quot;#Transformer-的基本架构&quot; class=&quot;headerlink&quot; title=&quot;Transformer 的基本架构&quot;&gt;&lt;/a&gt;Transformer 的基本架构&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Artificial Intelligence" scheme="http://alphazer01214.github.io/categories/Artificial-Intelligence/"/>
    
    
    <category term="注意力机制" scheme="http://alphazer01214.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Deepseek论文学习</title>
    <link href="http://alphazer01214.github.io/2025/01/27/Deepseek%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/"/>
    <id>http://alphazer01214.github.io/2025/01/27/Deepseek%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-01-27T15:54:05.000Z</published>
    <updated>2025-01-29T21:46:30.054Z</updated>
    
    <content type="html"><![CDATA[<p>DeepSeek</p><p>本文不严格按照论文顺序，本文有太多未了解的内容，我需要针对这些概念进一步学习。</p><h2 id="Introduction-部分"><a href="#Introduction-部分" class="headerlink" title="Introduction 部分"></a>Introduction 部分</h2><p>Post Training在训练过程起重要作用，能够提高推理任务的准确性。相对pre-training，其需要计算资源更少。</p><blockquote><p><strong>Post-training</strong>：训练后处理，是指在模型完成主要训练后，为进一步提升性能或适应特定需求而进行的一系列优化和调整步骤。这些步骤通常包括模型压缩、微调、量化和蒸馏等技术。</p><p>通过该过程，模型可以自主探索一个复杂问题的思维链。</p><p>实现方式：</p><ol><li><strong>模型压缩</strong>：<ul><li><strong>剪枝（Pruning）</strong>：移除不重要的神经元或权重，减少模型复杂度。</li><li><strong>量化（Quantization）</strong>：将浮点数权重转换为低精度表示，如8位整数，以提升推理速度并减少内存占用。</li></ul></li><li><strong>微调（Fine-tuning）</strong>：<ul><li><strong>领域适应（Domain Adaptation）</strong>：在特定领域数据上进一步训练，以提高在该领域的表现。</li><li><strong>任务特定微调（Task-specific Fine-tuning）</strong>：针对特定任务调整模型参数。</li></ul></li><li><strong>知识蒸馏（Knowledge Distillation）</strong>：<ul><li>使用大模型（教师模型）指导小模型（学生模型）训练，以在保持性能的同时减少模型大小和计算需求。</li></ul></li><li><strong>模型优化</strong>：<ul><li><strong>硬件优化</strong>：针对特定硬件（如GPU、TPU）优化模型，提升推理效率。</li><li><strong>软件优化</strong>：使用高效推理框架（如TensorRT、ONNX Runtime）加速模型推理。</li></ul></li></ol></blockquote><p>对于推理能力，OpenAI的o1使用<strong>推理时缩放</strong>，通过加长思维链实现推理过程。但这一缩放过程的有效性是一大挑战。尽管有其它方法诸如过程奖励、强化学习、开发类似<strong>Monte Carlo Tree Search</strong>，<strong>Beam Search</strong>等算法，但都无法达到o1的水平。</p><p>而DeepSeek R1使用纯粹的<strong>强化学习</strong>，而不使用任何监督数据。基于V3的<strong>GRPO</strong>作为强化学习的框架，R1表现了强大的推理能力。</p><blockquote><p><strong>GRPO</strong>：Group Relative Policy Optimization，DeepSeek V3使用的策略优化方法，对应V3报告中5.2.2部分。</p><p>对于一个问题q，GRPO在旧的<strong>策略模型</strong>$\pi_{\theta old}$输出中采样一组数据，并进行优化。具体公式 见报告。</p></blockquote><p>但DeepSeek存在问题：可读性差、语言混杂。解决该问题的方法是，将一些<strong>冷启动数据</strong>（即对于模型而言是“新的”数据，以前没有品鉴过）提供给V3模型，进行以推理为中心的强化学习，在找到局部最优解时，再从强化学习检查点的<strong>拒绝采样</strong>，结合V3在各个领域内的监督数据，创造新的微调数据，进行重复训练。如此一来，该检查点就经历了额外的强化学习步骤，进而实现对各个情景下prompt的考虑。</p><p>DeepSeek的”思考——解答“模式有一些有趣的特性。对于显式的思考过程，比如在解数学题时，可能会有”灵光一现”，即找到了其它更好的思考方式，并重新沿着这种思考方式前进，进而找到正解。</p><h2 id="Approach-部分"><a href="#Approach-部分" class="headerlink" title="Approach 部分"></a>Approach 部分</h2><p>相较于以往的模型使用大规模的监督数据提高性能，DeepSeek更注重提高模型的自主思考能力（推理能力）。而推理能力可以通过大规模的强化学习提高，甚至不需要冷启动数据。当然，冷启动数据能够更好地训练模型。</p><h3 id="强化学习算法"><a href="#强化学习算法" class="headerlink" title="强化学习算法"></a>强化学习算法</h3><h4 id="GRPO"><a href="#GRPO" class="headerlink" title="GRPO"></a>GRPO</h4><p>此算法旨在减少训练的开支，分为以下步骤。</p><h5 id="优势值计算"><a href="#优势值计算" class="headerlink" title="优势值计算"></a>优势值计算</h5><p>第$i$个样本的优势值$A_i$，由样本奖励值$r_i$，以及平均值（基线）$b$决定：<br>$$<br>A_i &#x3D; r_i-b \<br>b &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}r_i<br>$$</p><h5 id="策略优化函数"><a href="#策略优化函数" class="headerlink" title="策略优化函数"></a>策略优化函数</h5><p>$$<br>L(\theta)&#x3D;E[min(\frac{\pi_{\theta}(a|s)}{\pi_{\theta_{old}}(a|s)}A_i, clip(\frac{\pi_{\theta}(a|s)}{\pi_{\theta_{old}}(a|s)}, 1-ϵ,1+ϵ)A_i)]<br>$$</p><p>其中，</p><p><strong>概率比</strong>：<br>$$<br>\frac{\pi_{\theta}(a|s)}{\pi_{\theta_{old}}(a|s)}<br>$$<br>$s$表示状态，$a$表示动作，$a|s$即条件概率。$\pi_\theta$表示策略，因此$\pi_\theta(a|s)$表示在某个策略下，对于状态s，执行操作a的概率。对于新旧策略，执行该操作的概率有所变化，即体现了新旧策略在动作选择上的差异。</p><p><strong>等待更深入学习</strong></p><h4 id="奖励建模-Reward-Modelling"><a href="#奖励建模-Reward-Modelling" class="headerlink" title="奖励建模(Reward Modelling)"></a>奖励建模(Reward Modelling)</h4><blockquote><p>在强化学习中，<strong>Reward Modelling（奖励建模）</strong> 是指通过设计或学习一个奖励函数，以准确反映智能体在环境中应追求的目标的过程。它是强化学习系统的核心组成部分，因为奖励函数直接决定了智能体的行为优化方向。(DeepSeek)</p></blockquote><p>“奖励”来源于训练的源。其来源于两方面：</p><ol><li><strong>准确度奖励</strong>，即对于有正解的问题，其输出是否与答案匹配</li><li><strong>格式奖励</strong>，即让模型将深度思考的内容列于标签 <code>&lt;think&gt;</code>之间</li></ol><p>DeepSeek没有使用<strong>神经奖励模型</strong>。(<strong>待补充</strong>)在大规模强化学习中，可能会导致reward hacking，且需要额外的训练资源。</p><h3 id="DeepSeek-R1的构建"><a href="#DeepSeek-R1的构建" class="headerlink" title="DeepSeek R1的构建"></a>DeepSeek R1的构建</h3><h4 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h4><h4 id="模型蒸馏"><a href="#模型蒸馏" class="headerlink" title="模型蒸馏"></a>模型蒸馏</h4><p>蒸馏模型，即将一个庞大的模型压缩到一个较小的规模。模型蒸馏的实质是<strong>知识蒸馏</strong>，即大模型的架构优势是无法直接继承给蒸馏模型的，类比教师和学生的关系，<strong>教师模型</strong>将”知识”传授给<strong>学生模型</strong>。</p><p>神经网络就是一个黑箱，因此理解其内涵就应该以一种更抽象的思维。例如，一个词向量有着上百个维度，某些维度的数据用来存储词性，某些用来存储发音，甚至有些存储了我们不能理解的特征。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DeepSeek&lt;/p&gt;
&lt;p&gt;本文不严格按照论文顺序，本文有太多未了解的内容，我需要针对这些概念进一步学习。&lt;/p&gt;
&lt;h2 id=&quot;Introduction-部分&quot;&gt;&lt;a href=&quot;#Introduction-部分&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Artificial Intelligence" scheme="http://alphazer01214.github.io/categories/Artificial-Intelligence/"/>
    
    
    <category term="论文" scheme="http://alphazer01214.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——动态规划与字符串</title>
    <link href="http://alphazer01214.github.io/2025/01/22/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://alphazer01214.github.io/2025/01/22/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2025-01-21T19:55:09.000Z</published>
    <updated>2025-01-22T05:25:01.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>字符串，包括其排列组合，以及匹配算法，与动态规划密切相关。这篇文章总结一些字符串匹配算法，并解决一些字符串相关动态规划问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;字符串，包括其排列组合，以及匹配算法，与动态规划密切相关。这篇文章总结一些字符串匹配算法，并解决一些字符串相关动态规划问题。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://alphazer01214.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——动态规划与背包问题</title>
    <link href="http://alphazer01214.github.io/2025/01/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://alphazer01214.github.io/2025/01/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2025-01-21T10:49:56.000Z</published>
    <updated>2025-01-21T12:30:45.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目一：前缀和、动态规划"><a href="#题目一：前缀和、动态规划" class="headerlink" title="题目一：前缀和、动态规划"></a>题目一：前缀和、动态规划</h1><p><em>这是LeetCode第2218题，今天的每日一题</em>。</p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><blockquote><p>一张桌子上总共有 <code>n</code> 个硬币 <strong>栈</strong> 。每个栈有 <strong>正整数</strong> 个带面值的硬币。</p><p>每一次操作中，你可以从任意一个栈的 <strong>顶部</strong> 取出 1 个硬币，从栈中移除它，并放入你的钱包里。</p><p>给你一个列表 <code>piles</code> ，其中 <code>piles[i]</code> 是一个整数数组，分别表示第 <code>i</code> 个栈里 <strong>从顶到底</strong> 的硬币面值。同时给你一个正整数 <code>k</code> ，请你返回在 <strong>恰好</strong> 进行 <code>k</code> 次操作的前提下，你钱包里硬币面值之和 <strong>最大为多少</strong> 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/09/e1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [[1,100,3],[7,8,9]], k = 2</span><br><span class="line">输出：101</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首要目标是找到递推关系。</p><p>首先确定<strong>两个维度</strong>。因为取硬币的行为包含两个因素，一个是<strong>现在正在取哪一个栈里的硬币</strong>，一个是<strong>还能取多少硬币</strong>。分别记为$i,j$，那么确定：<br>$$<br>dp[i][j]<br>$$<br>为从前$i$个栈中，<strong>至多</strong>取出$j$个硬币，面值的<strong>最大值</strong>。</p><p>这个状态由前$i-1$个栈的情况转移而来。如何转移？可以对第$i$个栈中要取多少硬币进行<strong>枚举</strong>，如果从该栈中取了$w$个，那么之前的$i-1$个栈就<strong>至多</strong>只能取$j-w$个。取这些情况的<strong>最大值</strong>，这样一来，状态转移方程就可以确定：<br>$$<br>dp[i][j] &#x3D; max(dp[i-1][j-w]) + v<br>$$<br>其中，$v$是第$i$个栈中取$w$个硬币所产生的价值。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValueOfCoins</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; piles, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2333</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2333</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; piles.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++)&#123;</span><br><span class="line">                dp[i<span class="number">+1</span>][j] = dp[i][j];   <span class="comment">// 相当于第i+1个栈不取硬币，因为piles[i]的下标最小只有0</span></span><br><span class="line">                <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">1</span>; w &lt;= <span class="built_in">min</span>((<span class="type">int</span>) piles[i].<span class="built_in">size</span>(), j); w++)&#123;</span><br><span class="line">                    v += piles[i][w<span class="number">-1</span>];   <span class="comment">// 获取前缀和</span></span><br><span class="line">                    dp[i<span class="number">+1</span>][j] = <span class="built_in">max</span>(dp[i<span class="number">+1</span>][j], dp[i][j-w] + v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[piles.<span class="built_in">size</span>()][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，动态规划就是一种brute force，它<strong>隐式地</strong>表示了全部最佳情况，并逐一<strong>枚举</strong>。这是因为仅用贪心算法，其最优解性是难以证明的，而通过对最优解情况的隐式定义，并逐一递推，即可得到结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目一：前缀和、动态规划&quot;&gt;&lt;a href=&quot;#题目一：前缀和、动态规划&quot; class=&quot;headerlink&quot; title=&quot;题目一：前缀和、动态规划&quot;&gt;&lt;/a&gt;题目一：前缀和、动态规划&lt;/h1&gt;&lt;p&gt;&lt;em&gt;这是LeetCode第2218题，今天的每日一题&lt;/</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://alphazer01214.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——生成搜索二叉树</title>
    <link href="http://alphazer01214.github.io/2025/01/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://alphazer01214.github.io/2025/01/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2025-01-20T07:29:14.000Z</published>
    <updated>2025-01-21T13:41:54.319Z</updated>
    
    <content type="html"><![CDATA[<p><em>这是LeetCode第95、96题</em></p><h2 id="不同二叉搜索树的种类"><a href="#不同二叉搜索树的种类" class="headerlink" title="不同二叉搜索树的种类"></a>不同二叉搜索树的种类</h2><p>首先是研究二叉搜索树的数量性质：</p><blockquote><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p></blockquote><p><strong>二叉搜索树</strong>，指对于根节点，左子树所有元素均小于该节点，右子树所有节点都大于这个节点。</p><p>例如，当n&#x3D;1，显然只有一种情况。而当n&#x3D;2，就有2种情况，这是因为1、2都可以作为根节点，产生2个不同的树。</p><p>特别地，当n&#x3D;0也是一种情况，我们把NULL也看作一棵树。</p><p>接下来考虑n&#x3D;3，它的根节点可以是1、2、3。从二叉搜索树性质出发：</p><ul><li>当根节点为1，<strong>它不会有左子树</strong>，而右子树有两个节点。</li><li>当根节点为2，<strong>它一定有左右子树</strong>，而且各有一个节点。</li><li>当根节点为3，<strong>情况与1类似</strong>。</li></ul><p>这样，就找到了一个子问题。例如，当根节点为1，它的子问题就是：<strong>没有节点的二叉搜索树有几种情况，有2个节点的二叉搜索树有几种情况</strong>。</p><p>推广到一般情况并以此列出方程：<br>$$<br>dp[i] &#x3D; \sum_{j&#x3D;0}^{i-1}dp[j]dp[i-j-1]<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">23</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>; i &lt;= <span class="number">19</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">                dp[i] += dp[j]*dp[i-j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="列出所有不同的二叉搜索树"><a href="#列出所有不同的二叉搜索树" class="headerlink" title="列出所有不同的二叉搜索树"></a>列出所有不同的二叉搜索树</h2><p>列出具体的二叉树，它们的头节点构成了一个vector。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"><span class="meta"># class TreeNode:</span></span><br><span class="line"><span class="meta">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="meta">#         self.val = val</span></span><br><span class="line"><span class="meta">#         self.left = left</span></span><br><span class="line"><span class="meta">#         self.right = right</span></span><br></pre></td></tr></table></figure><p>采用区间表示：定义$(left, right)$ 表示一棵起于$left$，终于$right$的<strong>二叉搜索树</strong>。</p><p>此时类似前一题的问题：头节点下接两棵子树，显然，对于一个根节点值为$i$的树，左边应该是由$[left, i-1]$构成的，而右边是由$[i+1, right]$构成的。</p><p>思考：<strong>递推关系和返回值应该是什么</strong>？</p><p>假定有一个函数$dfs(left,right)$用于构造如上述的树，那么在$left &#x3D; right$时，它应该是一个节点；在$left&gt;right$时，它应该是空的。在$left&lt;right$时，<strong>它是一棵树</strong>.</p><p>*因为是一棵树，所以返回类型应该是TreeNode**吗？</p><p>再回到构造过程以及题目，题目要求返回的是一个<code>vector&lt;TreeNode*&gt;</code>，它代表着<strong>树的集合</strong>。</p><p>而子问题：左右子树，它们<strong>同样是树的集合</strong>。</p><p>对于一个节点，它的左右子树都是一个集合，代表着不同情况的所有树，因此返回类型也应该是<code>vector&lt;TreeNode*&gt;</code>。特别地，对于$left&#x3D;right$，它是一个只有一个节点的树，当$left&gt;right$，它是一棵空的树。</p><p>值得一提的是，对于传入的left、right是区间，枚举其根节点（自身）还需要使用一个循环。</p><p>因此，构造的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br></pre></td></tr></table></figure><p>边界条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;   <span class="comment">// 注意：返回的是一个集合vector，&#123;&#125;不能省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的根节点构造左右子树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;TreeNode*&gt; res; <span class="comment">// result</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; ltree = <span class="built_in">dfs</span>(left, i<span class="number">-1</span>);</span><br><span class="line">vector&lt;TreeNode*&gt; rtree = <span class="built_in">dfs</span>(i<span class="number">+1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历左右子树集合中的所有树，并保存在res中，注：<strong>这一段在循环内</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;l: ltree)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r: rtree)&#123;</span><br><span class="line">        TreeNode* node = <span class="built_in">new</span>(TreeNode);</span><br><span class="line">        node-&gt;val = i;</span><br><span class="line">        node-&gt;left = l;   <span class="comment">// 当前节点的左子树是l，注意tree vector中虽然是节点，但实际上代表着一棵棵树</span></span><br><span class="line">        node-&gt;right = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再返回res即可。完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;   <span class="comment">// 注意：返回的是一个集合vector，&#123;&#125;不能省略</span></span><br><span class="line">    &#125;</span><br><span class="line">vector&lt;TreeNode*&gt; res; <span class="comment">// result</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; ltree = <span class="built_in">dfs</span>(left, i<span class="number">-1</span>);</span><br><span class="line">        vector&lt;TreeNode*&gt; rtree = <span class="built_in">dfs</span>(i<span class="number">+1</span>, right);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;l: ltree)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r: rtree)&#123;</span><br><span class="line">                TreeNode* node = <span class="built_in">new</span>(TreeNode);</span><br><span class="line">                node-&gt;val = i;</span><br><span class="line">                node-&gt;left = l;   <span class="comment">// 当前节点的左子树是l，注意tree vector中虽然是节点，但实际上代表着一棵棵树</span></span><br><span class="line">                node-&gt;right = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于C++为什么应该使用nullptr而不是NULL，是因为在C语言中，NULL是可以被强制类型转换的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;这是LeetCode第95、96题&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;不同二叉搜索树的种类&quot;&gt;&lt;a href=&quot;#不同二叉搜索树的种类&quot; class=&quot;headerlink&quot; title=&quot;不同二叉搜索树的种类&quot;&gt;&lt;/a&gt;不同二叉搜索树的种类&lt;/h2&gt;&lt;p&gt;首先是研</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="递归分治" scheme="http://alphazer01214.github.io/tags/%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB/"/>
    
    <category term="数据结构" scheme="http://alphazer01214.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="动态规划" scheme="http://alphazer01214.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="树" scheme="http://alphazer01214.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——滑动窗口</title>
    <link href="http://alphazer01214.github.io/2025/01/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://alphazer01214.github.io/2025/01/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2025-01-17T09:40:08.000Z</published>
    <updated>2025-01-17T10:46:34.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑利用一个<strong>单调的</strong>双端队列（deque）实现对区间最大值的维护。这个deque的前端就是这个区间的最大值，而其后续的部分则是接下来的窗口中有可能取到的最大值。</p><p>再考虑一个双指针，中间的部分即为窗口。我们只需要考虑left和right的元素即可。</p><p>例如：</p><blockquote><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">滑动窗口的位置                最大值             deque</span><br><span class="line">---------------               -----          --------</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3             3, -1</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3             3, -1, -3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5             5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5             5, 3</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6             6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7             7</span><br></pre></td></tr></table></figure><p>对于最开始的3个，最大值是3，然而在窗口向右移动时，若3弹出，-1有可能成为某个区间的最大值，因此在deque中保留了-1.</p><p>当5进入，它比deque中任何一个元素都大（只要它比deque front大），所以deque全部pop，并加入5.</p><p>如果进入的某个元素不大于deque front，却大于deque back，那么deque中比这个元素小的数在今后的区间内就不会成为最大值了，因此将其全部pop。</p><p>然而在实现的过程中，最令我困惑的是，窗口左端何时出，右端何时入。</p><p>声明需要的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>首先解决前k个的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(right &lt; k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] &gt; q.<span class="built_in">front</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_front</span>(nums[right]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[right] &gt; q.<span class="built_in">back</span>())&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br><span class="line">res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br></pre></td></tr></table></figure><p>再看其余的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[left] == q.<span class="built_in">front</span>())&#123;</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] &gt; q.<span class="built_in">front</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_front</span>(nums[right]);</span><br><span class="line">    &#125;<span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">if</span>(nums[right] &lt;= q.<span class="built_in">front</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">back</span>() &lt; nums[right])&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    right++;</span><br><span class="line">    left++;</span><br><span class="line">    res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，我们需要使此后的区间长度为k+1，因为需要判断front是否需要弹出。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(right &lt; k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &gt; q.<span class="built_in">front</span>())&#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push_front</span>(nums[right]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[right] &gt; q.<span class="built_in">back</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == q.<span class="built_in">front</span>())&#123;</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &gt; q.<span class="built_in">front</span>())&#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push_front</span>(nums[right]);</span><br><span class="line">            &#125;<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt;= q.<span class="built_in">front</span>())&#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">back</span>() &lt; nums[right])&#123;</span><br><span class="line">                    q.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            left++;</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，有一个大小为 &lt;code&gt;k&lt;/code&gt; 的滑动窗口从数组的最左侧移</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://alphazer01214.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="队列" scheme="http://alphazer01214.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——堆、优先队列</title>
    <link href="http://alphazer01214.github.io/2025/01/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://alphazer01214.github.io/2025/01/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2025-01-14T23:48:43.000Z</published>
    <updated>2025-01-17T10:46:42.012Z</updated>
    
    <content type="html"><![CDATA[<p>这个页面等待填充。</p><p><a href="https://leetcode.cn/problems/maximum-number-of-eaten-apples/description/">https://leetcode.cn/problems/maximum-number-of-eaten-apples/description/</a></p><p><a href="https://leetcode.cn/problems/design-task-manager/description/">https://leetcode.cn/problems/design-task-manager/description/</a></p><p>股票买卖问题：若可同时持有多支股票，那么如何决策获得收益最大？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个页面等待填充。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/maximum-number-of-eaten-apples/description/&quot;&gt;https://leetcode.cn/problems/maximum-</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://alphazer01214.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="队列" scheme="http://alphazer01214.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——图的记忆化遍历</title>
    <link href="http://alphazer01214.github.io/2025/01/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E8%AE%B0%E5%BF%86%E5%8C%96%E9%81%8D%E5%8E%86/"/>
    <id>http://alphazer01214.github.io/2025/01/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E8%AE%B0%E5%BF%86%E5%8C%96%E9%81%8D%E5%8E%86/</id>
    <published>2025-01-14T23:38:15.000Z</published>
    <updated>2025-01-17T10:22:54.857Z</updated>
    
    <content type="html"><![CDATA[<p>这个页面待填充。</p><h1 id="ABC351D-Grid-and-Magnet"><a href="#ABC351D-Grid-and-Magnet" class="headerlink" title="[ABC351D] Grid and Magnet"></a>[ABC351D] Grid and Magnet</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>有一个用字符类型表示的 $H$ 行 $W$ 列的地图 $S$，如果 $S_{i,j}$ 是字符 <code>.</code> 则代表这一格是空地，如果是 <code>#</code> 则代表这一格上有一个磁铁。现有一个小人从一个格子上出发，每次可以到达与之相邻（上、下、左、右）的四个格子，但如果有一个磁铁与之相邻（上下左右的四个格子中至少有一个磁铁）他就不能动了。求小人从某一格出发，经过任意多次运动，可以到达的格子的最大数量。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ S_1 $ $ S_2 $ $ \vdots $ $ S_H $</p></blockquote><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を出力せよ。</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">.#...</span><br><span class="line">.....</span><br><span class="line">.#..#</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">..#</span><br><span class="line">#..</span><br><span class="line">..#</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="制約"><a href="#制約" class="headerlink" title="制約"></a>制約</h3><ul><li>$ 1\leq\ H,W\leq\ 1000 $</li><li>$ H,W $ は整数</li><li>$ S_i $ は <code>.</code> と <code>#</code> のみからなる長さ $ W $ の文字列</li><li>磁石の置かれていないマスが少なくとも $ 1 $ つ存在する。</li></ul><h3 id="Sample-Explanation-1"><a href="#Sample-Explanation-1" class="headerlink" title="Sample Explanation 1"></a>Sample Explanation 1</h3><p>上から $ i $ 行目かつ左から $ j $ 列目のマスを $ (i,j) $ で表します。 高橋君が最初に $ (2,3) $ にいるとき、高橋君の移動の例としては次のようなものなどが考えられます。 - $ (2,3)\to\ (2,4)\to\ (1,4)\to\ (1,5)\to\ (2,5) $ - $ (2,3)\to\ (2,4)\to\ (3,4) $ - $ (2,3)\to\ (2,2) $ - $ (2,3)\to\ (1,3) $ - $ (2,3)\to\ (3,3) $ よって、途中で到達しているマスも含めて高橋君は $ (2,3) $ から少なくとも $ 9 $ 個のマスに到達することができます。 一方、これら以外のマスには到達することができないため、$ (2,3) $ の自由度は $ 9 $ となります。 これは磁石が置かれていない各マスの自由度のうち最大であるため、$ 9 $ を出力します。</p><h3 id="Sample-Explanation-2"><a href="#Sample-Explanation-2" class="headerlink" title="Sample Explanation 2"></a>Sample Explanation 2</h3><p>磁石が置かれていないどのマスについても、上下左右に隣り合うマスのいずれかに磁石が置かれています。 よって、磁石が置かれていないどのマスからも移動することはできず、マスの自由度は $ 1 $ となります。 そのため、$ 1 $ を出力します。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个页面待填充。&lt;/p&gt;
&lt;h1 id=&quot;ABC351D-Grid-and-Magnet&quot;&gt;&lt;a href=&quot;#ABC351D-Grid-and-Magnet&quot; class=&quot;headerlink&quot; title=&quot;[ABC351D] Grid and Magnet&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://alphazer01214.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://alphazer01214.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>知更鸟专辑</title>
    <link href="http://alphazer01214.github.io/2025/01/14/%E7%9F%A5%E6%9B%B4%E9%B8%9F%E4%B8%93%E8%BE%91/"/>
    <id>http://alphazer01214.github.io/2025/01/14/%E7%9F%A5%E6%9B%B4%E9%B8%9F%E4%B8%93%E8%BE%91/</id>
    <published>2025-01-14T15:29:32.000Z</published>
    <updated>2025-01-17T10:31:12.738Z</updated>
    
    <content type="html"><![CDATA[<p>It’s actually a test.</p><p>试试加入图片。</p><p><img src="/img/1.jpg" alt="1"></p><p><img src="/img/2.jpg" alt="2"></p><p><img src="/img/3.jpg" alt="3"></p><p>虽然专辑到手了，但光驱还差个电源线（悲）</p><p>试了好几次终于是能显示图片了，图片资源放在img文件夹中，还不知道要怎么实现单独给post开个资源文件夹，img文件夹的资源是网站共享的，而且在Typora编辑的时候没办法看到图片（悲）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;It’s actually a test.&lt;/p&gt;
&lt;p&gt;试试加入图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2.jpg&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/3.</summary>
      
    
    
    
    <category term="Routine" scheme="http://alphazer01214.github.io/categories/Routine/"/>
    
    
    <category term="二次元" scheme="http://alphazer01214.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"/>
    
    <category term="游戏" scheme="http://alphazer01214.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="音乐" scheme="http://alphazer01214.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Markdown Cheatsheet</title>
    <link href="http://alphazer01214.github.io/2025/01/13/Markdown-Cheatsheet/"/>
    <id>http://alphazer01214.github.io/2025/01/13/Markdown-Cheatsheet/</id>
    <published>2025-01-13T13:51:28.000Z</published>
    <updated>2025-01-17T10:44:07.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一个Markdown语法的速查表"><a href="#这是一个Markdown语法的速查表" class="headerlink" title="这是一个Markdown语法的速查表"></a>这是一个Markdown语法的速查表</h1><h1 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h1><p>在HTML中，标题采用”<code>&lt;h1&gt;、&lt;h2&gt;</code>“等标签，在Markdown中，这被简化为了“#”。你可以使用一定数量的”#”用于标识一级、二级乃至更多级的标题。注意：<strong>&quot;#&quot; 与标题文字之间需要一个空格</strong>。</p><blockquote><h2 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h2><h3 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h3></blockquote><p>由于Markdown是兼容HTML的，因此我们可以使用HTML的样式语法对文档标题进行修饰。</p><p>例如，若要居中标题，可以使用如下语法：</p><p><code>&lt;h1 align=center&gt; 居中标题 &lt;/h1&gt;</code></p><p>效果：</p><blockquote><h2 align=center> 居中标题 </h2></blockquote><p>还有更多的语法可供使用，例如：</p><p><code>&lt;center&gt; &lt;h1&gt; Center Title &lt;/h1&gt; &lt;/center&gt;</code></p><p>其中，单独的center标签表示为文字居中。</p><h1 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h1><p>Markdown中，如果需要换行，请打两次回车键。当然，也可以使用HTML语法。</p><p><code>&lt;p&gt; 这是一个段落的第一行 &lt;br&gt; 这是第二行 &lt;/p&gt;</code></p><p>效果：</p><blockquote><p> 这是一个段落的第一行 <br> 这是第二行 </p></blockquote><h1 id="转义方法"><a href="#转义方法" class="headerlink" title="转义方法"></a>转义方法</h1><p>写这篇文章的时候就发现，要把Markdown语法给端上来还是需要一些操作的，否则这些就会被自动渲染。</p><h2 id="方法一：使用反斜杠"><a href="#方法一：使用反斜杠" class="headerlink" title="方法一：使用反斜杠 \"></a>方法一：使用反斜杠 \</h2><p># &lt;h1&gt; **** </p><h2 id="方法二：使用代码段"><a href="#方法二：使用代码段" class="headerlink" title="方法二：使用代码段 &#96;&#96;"></a>方法二：使用代码段 &#96;&#96;</h2><p><code>&lt;h1&gt;&lt;h2&gt; # **</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;这是一个Markdown语法的速查表&quot;&gt;&lt;a href=&quot;#这是一个Markdown语法的速查表&quot; class=&quot;headerlink&quot; title=&quot;这是一个Markdown语法的速查表&quot;&gt;&lt;/a&gt;这是一个Markdown语法的速查表&lt;/h1&gt;&lt;h1 id=&quot;标</summary>
      
    
    
    
    <category term="Productivity" scheme="http://alphazer01214.github.io/categories/Productivity/"/>
    
    
    <category term="Markdown" scheme="http://alphazer01214.github.io/tags/Markdown/"/>
    
    <category term="LaTeX" scheme="http://alphazer01214.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>有序链表的合并——答案倒推原理</title>
    <link href="http://alphazer01214.github.io/2025/01/13/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6/"/>
    <id>http://alphazer01214.github.io/2025/01/13/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6/</id>
    <published>2025-01-13T03:13:06.000Z</published>
    <updated>2025-01-16T16:40:40.322Z</updated>
    
    <content type="html"><![CDATA[<p><em>该题是LeetCode的第23题</em></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br></pre></td></tr></table></figure><h2 id="思路分析与代码解析"><a href="#思路分析与代码解析" class="headerlink" title="思路分析与代码解析"></a>思路分析与代码解析</h2><p>典型的归并排序问题，在先前的文章中也提到归并排序是如何通过递归来实现的，事实上，归并排序的过程就可以看作是双指针，<br>两个列表逐一遍历，最后变成一个列表。但对于链表，这个过程并不简单，因为链表还有“连接”这一步。<br>我们先端上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *left, ListNode *right)</span></span>&#123;</span><br><span class="line">        ListNode *lptr = left;</span><br><span class="line">        ListNode *rptr = right;</span><br><span class="line">        ListNode *res = <span class="built_in">new</span>(ListNode);</span><br><span class="line">        ListNode *head = res;</span><br><span class="line">        <span class="keyword">while</span>(lptr &amp;&amp; rptr)&#123;</span><br><span class="line">            ListNode *node = <span class="built_in">new</span>(ListNode);</span><br><span class="line">            <span class="keyword">if</span>(lptr-&gt;val &lt; rptr-&gt;val)&#123;</span><br><span class="line">                node-&gt;val = lptr-&gt;val;</span><br><span class="line">                lptr = lptr-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node-&gt;val = rptr-&gt;val;</span><br><span class="line">                rptr = rptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            res-&gt;next = node;</span><br><span class="line">            res = res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lptr == <span class="literal">NULL</span> &amp;&amp; rptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            res-&gt;next = rptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lptr != <span class="literal">NULL</span> &amp;&amp; rptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            res-&gt;next = lptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge_sort</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">merge_sort</span>(lists, left, (left + right)/<span class="number">2</span>), <span class="built_in">merge_sort</span>(lists, (left + right)/<span class="number">2</span> + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge_sort</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先从merge的部分说起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ListNode* merge(ListNode *left, ListNode *right)&#123;</span><br><span class="line">    ListNode *lptr = left;</span><br><span class="line">    ListNode *rptr = right;</span><br><span class="line">    ListNode *res = new(ListNode);</span><br><span class="line">    ListNode *head = res;</span><br><span class="line">    while(lptr &amp;&amp; rptr)&#123;</span><br><span class="line">        ListNode *node = new(ListNode);</span><br><span class="line">        if(lptr-&gt;val &lt; rptr-&gt;val)&#123;</span><br><span class="line">            node-&gt;val = lptr-&gt;val;</span><br><span class="line">            lptr = lptr-&gt;next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            node-&gt;val = rptr-&gt;val;</span><br><span class="line">            rptr = rptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        res-&gt;next = node;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(lptr == NULL &amp;&amp; rptr != NULL)&#123;</span><br><span class="line">        res-&gt;next = rptr;</span><br><span class="line">    &#125;</span><br><span class="line">    if(lptr != NULL &amp;&amp; rptr == NULL)&#123;</span><br><span class="line">        res-&gt;next = lptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步，我们将两个<strong>有序</strong>链表，以它们的头节点作为参数left、right传入了merge函数。</p><p>动用左右指针，逐个遍历，最后得到结果链表，并将这个链表返回。由于使用的是尾插，因此应该返回其头节点的下一节点。</p><p>注意：这个步骤在传入链表均为空链表时依旧是有效的。</p><p>再说说merge_sort这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListNode* merge_sort(vector&lt;ListNode*&gt;&amp; lists, int left, int right)&#123;</span><br><span class="line">    if(left &gt;= right)&#123;</span><br><span class="line">        return lists[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return merge(merge_sort(lists, left, (left + right)/2), merge_sort(lists, (left + right)/2 + 1, right));</span><br></pre></td></tr></table></figure><p>这个函数接受3个参数，其中，lists是一个指针vector，用于存放所有链表的头节点。而left、right则是两个”指针”，这两个参数可以视作对<strong>这些</strong>链表进行切片操作。归并的第一步就是二分的过程，不断二分到left&#x3D;&#x3D;right时，返回lists[left]，如此一来，merge接受了两个头节点参数，合成了一个链表。这一个大链表作为返回值，<strong>是上一级merge_sort中，返回的merge函数的一个参数</strong>，不断向上“并”，实现了链表的合并。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;该题是LeetCode的第23题&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://alphazer01214.github.io/tags/C/"/>
    
    <category term="递归分治" scheme="http://alphazer01214.github.io/tags/%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB/"/>
    
    <category term="LeetCode" scheme="http://alphazer01214.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——Merge Sort</title>
    <link href="http://alphazer01214.github.io/2025/01/08/Merge-Sort/"/>
    <id>http://alphazer01214.github.io/2025/01/08/Merge-Sort/</id>
    <published>2025-01-08T15:20:36.000Z</published>
    <updated>2025-01-14T15:27:57.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序的主要思想"><a href="#归并排序的主要思想" class="headerlink" title="归并排序的主要思想"></a>归并排序的主要思想</h1><p><strong>归</strong>——将数组分成两部分，分别进行排序。<br><strong>并</strong>——将已经排序的两个数组合并起来。</p><p>“并”的部分对于我而言有点难以理解，接下来的重点会放在“并”上面。</p><h1 id="代码实现——步骤一"><a href="#代码实现——步骤一" class="headerlink" title="代码实现——步骤一"></a>代码实现——步骤一</h1><p>第一步就是使用递归将数组二分，关键在于利用下标实现二分操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">// left right are index</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (right+left)/<span class="number">2</span>;</span><br><span class="line">        merge_sort(arr, left, mid);</span><br><span class="line">        merge_sort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">        msort(arr, left, right, mid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>递归需要终止条件，当长度为1，利用下标表示就是left&gt;&#x3D;right，此时递归结束，返回上一级。<br>接着将二分的索引作为参数（就是新二分出来数组的left，right），进行递归操作，实现原数组的对半分。<br>分割操作之后是msort，稍后讲解。<br>注意：<strong>整个过程中arr本身的长度都是不变的</strong>！而且arr的索引还是从0开始到结束，也就是说，我们并不是真的将数组分割成了一个一个新数组，<strong>我们都是在原数组上进行操作</strong>，我们所有操作都是通过下标实现的。</p><h1 id="代码实现——步骤二"><a href="#代码实现——步骤二" class="headerlink" title="代码实现——步骤二"></a>代码实现——步骤二</h1><p>对于一次并，示意图如下：<br><img src="/../_images/mergesort.png" alt="归并示意图"></p><ol><li>我们假设有两个<strong>已排序</strong>的数组（假设已排序，这样就能先解决将两数组合并的问题）</li><li>这两个数组被拼成了一个数组，下标如图所示</li><li>对这么一个数组进行排序，只需要一次遍历操作<br>我们引入两个类似指针的变量<strong>i, j</strong>，一个指向这个数组的开头，一个指向中间，那么我们就能通过比较<strong>i, j</strong>索引对应的值来进行排序。<br>如果只有这一个数组，排序有些困难，于是我们选择引入新的数组（即复制一遍原数组），然后<strong>把排序结果保存回原数组</strong>。<br>注意：我们这里加入了<strong>left、right、mid</strong>变量来获取这个数组的开头、结尾与中间，其中这三个变量都是索引值。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp_arr[right];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">    <span class="comment">// copy to a temp arr</span></span><br><span class="line">    tmp_arr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = left, j = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = left; k &lt;= right; k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; mid)&#123;</span><br><span class="line">        arr[k] = tmp_arr[j++];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt; right)&#123;</span><br><span class="line">        arr[k] = tmp_arr[i++];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp_arr[i] &lt; tmp_arr[j])&#123;</span><br><span class="line">        arr[k] = tmp_arr[i++];</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(tmp_arr[i] &gt;= tmp_arr[j])&#123;</span><br><span class="line">        arr[k] = tmp_arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h2><p>在自行实现归并排序的过程中，最纠结的就是如何规定数组的长度，但实际上长度并不重要，因为最后都可以按照其索引值将结果复制回原数组。<br>在分成单个数组时，回到了上一步两个数组的状态，而这两个数组长度一定小于等于2，由于msort的过程中一次只能处理一个数组，因此实际上，msort是先分别排序了这两个数组，它们混合进了arr[]，然后再进入msort进行排序。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>在面对元素较少的数组时，可以考虑其它排序方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实我认为“将数组分割再合并”的说法非常令人费解，因为这样就会让人有“把两个数组传进一个函数，这个函数去把这两个数组首尾相接拼起来”的感觉，这种操作如何用递归实现？我还没有探索过。</p><p>实际上可以理解成，含n个元素的一个数组arr，我们先是有n个指针指着各个元素，然后两个两个比较大小&#x2F;对调元素，接下来指针减半（两个指针之间间隔一个位置），然后4个一组，每组有两个指针，进行比大小与对换元素的操作，然后指针再减半，以此类推</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;归并排序的主要思想&quot;&gt;&lt;a href=&quot;#归并排序的主要思想&quot; class=&quot;headerlink&quot; title=&quot;归并排序的主要思想&quot;&gt;&lt;/a&gt;归并排序的主要思想&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;归&lt;/strong&gt;——将数组分成两部分，分别进行排序。&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Alphazer01214&#39;s First Post</title>
    <link href="http://alphazer01214.github.io/2025/01/08/Alphazer01214-s-First-Post/"/>
    <id>http://alphazer01214.github.io/2025/01/08/Alphazer01214-s-First-Post/</id>
    <published>2025-01-08T13:30:34.000Z</published>
    <updated>2025-01-08T13:52:52.363Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World!</p><p>I created my very first page during my exam week.</p><p>By the way, it’s also my birthday.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hello World!&lt;/p&gt;
&lt;p&gt;I created my very first page during my exam week.&lt;/p&gt;
&lt;p&gt;By the way, it’s also my birthday.&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>

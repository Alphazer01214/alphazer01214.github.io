<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alphazer01214’s Blog</title>
  
  <subtitle>Alpha_零能的个人主页</subtitle>
  <link href="http://alphazer01214.github.io/atom.xml" rel="self"/>
  
  <link href="http://alphazer01214.github.io/"/>
  <updated>2025-01-21T12:30:45.032Z</updated>
  <id>http://alphazer01214.github.io/</id>
  
  <author>
    <name>Alpha_零能</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法学习笔记——动态规划与背包问题</title>
    <link href="http://alphazer01214.github.io/2025/01/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://alphazer01214.github.io/2025/01/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2025-01-21T10:49:56.000Z</published>
    <updated>2025-01-21T12:30:45.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目一：前缀和、动态规划"><a href="#题目一：前缀和、动态规划" class="headerlink" title="题目一：前缀和、动态规划"></a>题目一：前缀和、动态规划</h1><p><em>这是LeetCode第2218题，今天的每日一题</em>。</p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><blockquote><p>一张桌子上总共有 <code>n</code> 个硬币 <strong>栈</strong> 。每个栈有 <strong>正整数</strong> 个带面值的硬币。</p><p>每一次操作中，你可以从任意一个栈的 <strong>顶部</strong> 取出 1 个硬币，从栈中移除它，并放入你的钱包里。</p><p>给你一个列表 <code>piles</code> ，其中 <code>piles[i]</code> 是一个整数数组，分别表示第 <code>i</code> 个栈里 <strong>从顶到底</strong> 的硬币面值。同时给你一个正整数 <code>k</code> ，请你返回在 <strong>恰好</strong> 进行 <code>k</code> 次操作的前提下，你钱包里硬币面值之和 <strong>最大为多少</strong> 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/09/e1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [[1,100,3],[7,8,9]], k = 2</span><br><span class="line">输出：101</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首要目标是找到递推关系。</p><p>首先确定<strong>两个维度</strong>。因为取硬币的行为包含两个因素，一个是<strong>现在正在取哪一个栈里的硬币</strong>，一个是<strong>还能取多少硬币</strong>。分别记为$i,j$，那么确定：<br>$$<br>dp[i][j]<br>$$<br>为从前$i$个栈中，<strong>至多</strong>取出$j$个硬币，面值的<strong>最大值</strong>。</p><p>这个状态由前$i-1$个栈的情况转移而来。如何转移？可以对第$i$个栈中要取多少硬币进行<strong>枚举</strong>，如果从该栈中取了$w$个，那么之前的$i-1$个栈就<strong>至多</strong>只能取$j-w$个。取这些情况的<strong>最大值</strong>，这样一来，状态转移方程就可以确定：<br>$$<br>dp[i][j] &#x3D; max(dp[i-1][j-w]) + v<br>$$<br>其中，$v$是第$i$个栈中取$w$个硬币所产生的价值。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValueOfCoins</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; piles, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2333</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2333</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; piles.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++)&#123;</span><br><span class="line">                dp[i<span class="number">+1</span>][j] = dp[i][j];   <span class="comment">// 相当于第i+1个栈不取硬币，因为piles[i]的下标最小只有0</span></span><br><span class="line">                <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">1</span>; w &lt;= <span class="built_in">min</span>((<span class="type">int</span>) piles[i].<span class="built_in">size</span>(), j); w++)&#123;</span><br><span class="line">                    v += piles[i][w<span class="number">-1</span>];   <span class="comment">// 获取前缀和</span></span><br><span class="line">                    dp[i<span class="number">+1</span>][j] = <span class="built_in">max</span>(dp[i<span class="number">+1</span>][j], dp[i][j-w] + v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[piles.<span class="built_in">size</span>()][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，动态规划就是一种brute force，它<strong>隐式地</strong>表示了全部最佳情况，并逐一<strong>枚举</strong>。这是因为仅用贪心算法，其最优解性是难以证明的，而通过对最优解情况的隐式定义，并逐一递推，即可得到结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目一：前缀和、动态规划&quot;&gt;&lt;a href=&quot;#题目一：前缀和、动态规划&quot; class=&quot;headerlink&quot; title=&quot;题目一：前缀和、动态规划&quot;&gt;&lt;/a&gt;题目一：前缀和、动态规划&lt;/h1&gt;&lt;p&gt;&lt;em&gt;这是LeetCode第2218题，今天的每日一题&lt;/</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://alphazer01214.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——生成搜索二叉树</title>
    <link href="http://alphazer01214.github.io/2025/01/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://alphazer01214.github.io/2025/01/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2025-01-20T07:29:14.000Z</published>
    <updated>2025-01-21T13:41:54.319Z</updated>
    
    <content type="html"><![CDATA[<p><em>这是LeetCode第95、96题</em></p><h2 id="不同二叉搜索树的种类"><a href="#不同二叉搜索树的种类" class="headerlink" title="不同二叉搜索树的种类"></a>不同二叉搜索树的种类</h2><p>首先是研究二叉搜索树的数量性质：</p><blockquote><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p></blockquote><p><strong>二叉搜索树</strong>，指对于根节点，左子树所有元素均小于该节点，右子树所有节点都大于这个节点。</p><p>例如，当n&#x3D;1，显然只有一种情况。而当n&#x3D;2，就有2种情况，这是因为1、2都可以作为根节点，产生2个不同的树。</p><p>特别地，当n&#x3D;0也是一种情况，我们把NULL也看作一棵树。</p><p>接下来考虑n&#x3D;3，它的根节点可以是1、2、3。从二叉搜索树性质出发：</p><ul><li>当根节点为1，<strong>它不会有左子树</strong>，而右子树有两个节点。</li><li>当根节点为2，<strong>它一定有左右子树</strong>，而且各有一个节点。</li><li>当根节点为3，<strong>情况与1类似</strong>。</li></ul><p>这样，就找到了一个子问题。例如，当根节点为1，它的子问题就是：<strong>没有节点的二叉搜索树有几种情况，有2个节点的二叉搜索树有几种情况</strong>。</p><p>推广到一般情况并以此列出方程：<br>$$<br>dp[i] &#x3D; \sum_{j&#x3D;0}^{i-1}dp[j]dp[i-j-1]<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">23</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>; i &lt;= <span class="number">19</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">                dp[i] += dp[j]*dp[i-j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="列出所有不同的二叉搜索树"><a href="#列出所有不同的二叉搜索树" class="headerlink" title="列出所有不同的二叉搜索树"></a>列出所有不同的二叉搜索树</h2><p>列出具体的二叉树，它们的头节点构成了一个vector。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"><span class="meta"># class TreeNode:</span></span><br><span class="line"><span class="meta">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="meta">#         self.val = val</span></span><br><span class="line"><span class="meta">#         self.left = left</span></span><br><span class="line"><span class="meta">#         self.right = right</span></span><br></pre></td></tr></table></figure><p>采用区间表示：定义$(left, right)$ 表示一棵起于$left$，终于$right$的<strong>二叉搜索树</strong>。</p><p>此时类似前一题的问题：头节点下接两棵子树，显然，对于一个根节点值为$i$的树，左边应该是由$[left, i-1]$构成的，而右边是由$[i+1, right]$构成的。</p><p>思考：<strong>递推关系和返回值应该是什么</strong>？</p><p>假定有一个函数$dfs(left,right)$用于构造如上述的树，那么在$left &#x3D; right$时，它应该是一个节点；在$left&gt;right$时，它应该是空的。在$left&lt;right$时，<strong>它是一棵树</strong>.</p><p>*因为是一棵树，所以返回类型应该是TreeNode**吗？</p><p>再回到构造过程以及题目，题目要求返回的是一个<code>vector&lt;TreeNode*&gt;</code>，它代表着<strong>树的集合</strong>。</p><p>而子问题：左右子树，它们<strong>同样是树的集合</strong>。</p><p>对于一个节点，它的左右子树都是一个集合，代表着不同情况的所有树，因此返回类型也应该是<code>vector&lt;TreeNode*&gt;</code>。特别地，对于$left&#x3D;right$，它是一个只有一个节点的树，当$left&gt;right$，它是一棵空的树。</p><p>值得一提的是，对于传入的left、right是区间，枚举其根节点（自身）还需要使用一个循环。</p><p>因此，构造的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br></pre></td></tr></table></figure><p>边界条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;   <span class="comment">// 注意：返回的是一个集合vector，&#123;&#125;不能省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的根节点构造左右子树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;TreeNode*&gt; res; <span class="comment">// result</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; ltree = <span class="built_in">dfs</span>(left, i<span class="number">-1</span>);</span><br><span class="line">vector&lt;TreeNode*&gt; rtree = <span class="built_in">dfs</span>(i<span class="number">+1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历左右子树集合中的所有树，并保存在res中，注：<strong>这一段在循环内</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;l: ltree)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r: rtree)&#123;</span><br><span class="line">        TreeNode* node = <span class="built_in">new</span>(TreeNode);</span><br><span class="line">        node-&gt;val = i;</span><br><span class="line">        node-&gt;left = l;   <span class="comment">// 当前节点的左子树是l，注意tree vector中虽然是节点，但实际上代表着一棵棵树</span></span><br><span class="line">        node-&gt;right = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再返回res即可。完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;   <span class="comment">// 注意：返回的是一个集合vector，&#123;&#125;不能省略</span></span><br><span class="line">    &#125;</span><br><span class="line">vector&lt;TreeNode*&gt; res; <span class="comment">// result</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; ltree = <span class="built_in">dfs</span>(left, i<span class="number">-1</span>);</span><br><span class="line">        vector&lt;TreeNode*&gt; rtree = <span class="built_in">dfs</span>(i<span class="number">+1</span>, right);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;l: ltree)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r: rtree)&#123;</span><br><span class="line">                TreeNode* node = <span class="built_in">new</span>(TreeNode);</span><br><span class="line">                node-&gt;val = i;</span><br><span class="line">                node-&gt;left = l;   <span class="comment">// 当前节点的左子树是l，注意tree vector中虽然是节点，但实际上代表着一棵棵树</span></span><br><span class="line">                node-&gt;right = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于C++为什么应该使用nullptr而不是NULL，是因为在C语言中，NULL是可以被强制类型转换的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;这是LeetCode第95、96题&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;不同二叉搜索树的种类&quot;&gt;&lt;a href=&quot;#不同二叉搜索树的种类&quot; class=&quot;headerlink&quot; title=&quot;不同二叉搜索树的种类&quot;&gt;&lt;/a&gt;不同二叉搜索树的种类&lt;/h2&gt;&lt;p&gt;首先是研</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="递归分治" scheme="http://alphazer01214.github.io/tags/%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB/"/>
    
    <category term="数据结构" scheme="http://alphazer01214.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="动态规划" scheme="http://alphazer01214.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="树" scheme="http://alphazer01214.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——滑动窗口</title>
    <link href="http://alphazer01214.github.io/2025/01/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://alphazer01214.github.io/2025/01/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2025-01-17T09:40:08.000Z</published>
    <updated>2025-01-17T10:46:34.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑利用一个<strong>单调的</strong>双端队列（deque）实现对区间最大值的维护。这个deque的前端就是这个区间的最大值，而其后续的部分则是接下来的窗口中有可能取到的最大值。</p><p>再考虑一个双指针，中间的部分即为窗口。我们只需要考虑left和right的元素即可。</p><p>例如：</p><blockquote><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">滑动窗口的位置                最大值             deque</span><br><span class="line">---------------               -----          --------</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3             3, -1</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3             3, -1, -3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5             5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5             5, 3</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6             6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7             7</span><br></pre></td></tr></table></figure><p>对于最开始的3个，最大值是3，然而在窗口向右移动时，若3弹出，-1有可能成为某个区间的最大值，因此在deque中保留了-1.</p><p>当5进入，它比deque中任何一个元素都大（只要它比deque front大），所以deque全部pop，并加入5.</p><p>如果进入的某个元素不大于deque front，却大于deque back，那么deque中比这个元素小的数在今后的区间内就不会成为最大值了，因此将其全部pop。</p><p>然而在实现的过程中，最令我困惑的是，窗口左端何时出，右端何时入。</p><p>声明需要的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>首先解决前k个的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(right &lt; k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] &gt; q.<span class="built_in">front</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_front</span>(nums[right]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[right] &gt; q.<span class="built_in">back</span>())&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br><span class="line">res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br></pre></td></tr></table></figure><p>再看其余的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[left] == q.<span class="built_in">front</span>())&#123;</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] &gt; q.<span class="built_in">front</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_front</span>(nums[right]);</span><br><span class="line">    &#125;<span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">if</span>(nums[right] &lt;= q.<span class="built_in">front</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">back</span>() &lt; nums[right])&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    right++;</span><br><span class="line">    left++;</span><br><span class="line">    res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，我们需要使此后的区间长度为k+1，因为需要判断front是否需要弹出。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(right &lt; k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &gt; q.<span class="built_in">front</span>())&#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push_front</span>(nums[right]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[right] &gt; q.<span class="built_in">back</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == q.<span class="built_in">front</span>())&#123;</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &gt; q.<span class="built_in">front</span>())&#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push_front</span>(nums[right]);</span><br><span class="line">            &#125;<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt;= q.<span class="built_in">front</span>())&#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">back</span>() &lt; nums[right])&#123;</span><br><span class="line">                    q.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            left++;</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，有一个大小为 &lt;code&gt;k&lt;/code&gt; 的滑动窗口从数组的最左侧移</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://alphazer01214.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="队列" scheme="http://alphazer01214.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——堆、优先队列</title>
    <link href="http://alphazer01214.github.io/2025/01/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://alphazer01214.github.io/2025/01/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2025-01-14T23:48:43.000Z</published>
    <updated>2025-01-17T10:46:42.012Z</updated>
    
    <content type="html"><![CDATA[<p>这个页面等待填充。</p><p><a href="https://leetcode.cn/problems/maximum-number-of-eaten-apples/description/">https://leetcode.cn/problems/maximum-number-of-eaten-apples/description/</a></p><p><a href="https://leetcode.cn/problems/design-task-manager/description/">https://leetcode.cn/problems/design-task-manager/description/</a></p><p>股票买卖问题：若可同时持有多支股票，那么如何决策获得收益最大？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个页面等待填充。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/maximum-number-of-eaten-apples/description/&quot;&gt;https://leetcode.cn/problems/maximum-</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://alphazer01214.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="队列" scheme="http://alphazer01214.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——图的记忆化遍历</title>
    <link href="http://alphazer01214.github.io/2025/01/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E8%AE%B0%E5%BF%86%E5%8C%96%E9%81%8D%E5%8E%86/"/>
    <id>http://alphazer01214.github.io/2025/01/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E8%AE%B0%E5%BF%86%E5%8C%96%E9%81%8D%E5%8E%86/</id>
    <published>2025-01-14T23:38:15.000Z</published>
    <updated>2025-01-17T10:22:54.857Z</updated>
    
    <content type="html"><![CDATA[<p>这个页面待填充。</p><h1 id="ABC351D-Grid-and-Magnet"><a href="#ABC351D-Grid-and-Magnet" class="headerlink" title="[ABC351D] Grid and Magnet"></a>[ABC351D] Grid and Magnet</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>有一个用字符类型表示的 $H$ 行 $W$ 列的地图 $S$，如果 $S_{i,j}$ 是字符 <code>.</code> 则代表这一格是空地，如果是 <code>#</code> 则代表这一格上有一个磁铁。现有一个小人从一个格子上出发，每次可以到达与之相邻（上、下、左、右）的四个格子，但如果有一个磁铁与之相邻（上下左右的四个格子中至少有一个磁铁）他就不能动了。求小人从某一格出发，经过任意多次运动，可以到达的格子的最大数量。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ S_1 $ $ S_2 $ $ \vdots $ $ S_H $</p></blockquote><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を出力せよ。</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">.#...</span><br><span class="line">.....</span><br><span class="line">.#..#</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">..#</span><br><span class="line">#..</span><br><span class="line">..#</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="制約"><a href="#制約" class="headerlink" title="制約"></a>制約</h3><ul><li>$ 1\leq\ H,W\leq\ 1000 $</li><li>$ H,W $ は整数</li><li>$ S_i $ は <code>.</code> と <code>#</code> のみからなる長さ $ W $ の文字列</li><li>磁石の置かれていないマスが少なくとも $ 1 $ つ存在する。</li></ul><h3 id="Sample-Explanation-1"><a href="#Sample-Explanation-1" class="headerlink" title="Sample Explanation 1"></a>Sample Explanation 1</h3><p>上から $ i $ 行目かつ左から $ j $ 列目のマスを $ (i,j) $ で表します。 高橋君が最初に $ (2,3) $ にいるとき、高橋君の移動の例としては次のようなものなどが考えられます。 - $ (2,3)\to\ (2,4)\to\ (1,4)\to\ (1,5)\to\ (2,5) $ - $ (2,3)\to\ (2,4)\to\ (3,4) $ - $ (2,3)\to\ (2,2) $ - $ (2,3)\to\ (1,3) $ - $ (2,3)\to\ (3,3) $ よって、途中で到達しているマスも含めて高橋君は $ (2,3) $ から少なくとも $ 9 $ 個のマスに到達することができます。 一方、これら以外のマスには到達することができないため、$ (2,3) $ の自由度は $ 9 $ となります。 これは磁石が置かれていない各マスの自由度のうち最大であるため、$ 9 $ を出力します。</p><h3 id="Sample-Explanation-2"><a href="#Sample-Explanation-2" class="headerlink" title="Sample Explanation 2"></a>Sample Explanation 2</h3><p>磁石が置かれていないどのマスについても、上下左右に隣り合うマスのいずれかに磁石が置かれています。 よって、磁石が置かれていないどのマスからも移動することはできず、マスの自由度は $ 1 $ となります。 そのため、$ 1 $ を出力します。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个页面待填充。&lt;/p&gt;
&lt;h1 id=&quot;ABC351D-Grid-and-Magnet&quot;&gt;&lt;a href=&quot;#ABC351D-Grid-and-Magnet&quot; class=&quot;headerlink&quot; title=&quot;[ABC351D] Grid and Magnet&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://alphazer01214.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://alphazer01214.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>知更鸟专辑</title>
    <link href="http://alphazer01214.github.io/2025/01/14/%E7%9F%A5%E6%9B%B4%E9%B8%9F%E4%B8%93%E8%BE%91/"/>
    <id>http://alphazer01214.github.io/2025/01/14/%E7%9F%A5%E6%9B%B4%E9%B8%9F%E4%B8%93%E8%BE%91/</id>
    <published>2025-01-14T15:29:32.000Z</published>
    <updated>2025-01-17T10:31:12.738Z</updated>
    
    <content type="html"><![CDATA[<p>It’s actually a test.</p><p>试试加入图片。</p><p><img src="/img/1.jpg" alt="1"></p><p><img src="/img/2.jpg" alt="2"></p><p><img src="/img/3.jpg" alt="3"></p><p>虽然专辑到手了，但光驱还差个电源线（悲）</p><p>试了好几次终于是能显示图片了，图片资源放在img文件夹中，还不知道要怎么实现单独给post开个资源文件夹，img文件夹的资源是网站共享的，而且在Typora编辑的时候没办法看到图片（悲）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;It’s actually a test.&lt;/p&gt;
&lt;p&gt;试试加入图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2.jpg&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/3.</summary>
      
    
    
    
    <category term="Routine" scheme="http://alphazer01214.github.io/categories/Routine/"/>
    
    
    <category term="二次元" scheme="http://alphazer01214.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"/>
    
    <category term="游戏" scheme="http://alphazer01214.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="音乐" scheme="http://alphazer01214.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Markdown Cheatsheet</title>
    <link href="http://alphazer01214.github.io/2025/01/13/Markdown-Cheatsheet/"/>
    <id>http://alphazer01214.github.io/2025/01/13/Markdown-Cheatsheet/</id>
    <published>2025-01-13T13:51:28.000Z</published>
    <updated>2025-01-17T10:44:07.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一个Markdown语法的速查表"><a href="#这是一个Markdown语法的速查表" class="headerlink" title="这是一个Markdown语法的速查表"></a>这是一个Markdown语法的速查表</h1><h1 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h1><p>在HTML中，标题采用”<code>&lt;h1&gt;、&lt;h2&gt;</code>“等标签，在Markdown中，这被简化为了“#”。你可以使用一定数量的”#”用于标识一级、二级乃至更多级的标题。注意：<strong>&quot;#&quot; 与标题文字之间需要一个空格</strong>。</p><blockquote><h2 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h2><h3 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h3></blockquote><p>由于Markdown是兼容HTML的，因此我们可以使用HTML的样式语法对文档标题进行修饰。</p><p>例如，若要居中标题，可以使用如下语法：</p><p><code>&lt;h1 align=center&gt; 居中标题 &lt;/h1&gt;</code></p><p>效果：</p><blockquote><h2 align=center> 居中标题 </h2></blockquote><p>还有更多的语法可供使用，例如：</p><p><code>&lt;center&gt; &lt;h1&gt; Center Title &lt;/h1&gt; &lt;/center&gt;</code></p><p>其中，单独的center标签表示为文字居中。</p><h1 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h1><p>Markdown中，如果需要换行，请打两次回车键。当然，也可以使用HTML语法。</p><p><code>&lt;p&gt; 这是一个段落的第一行 &lt;br&gt; 这是第二行 &lt;/p&gt;</code></p><p>效果：</p><blockquote><p> 这是一个段落的第一行 <br> 这是第二行 </p></blockquote><h1 id="转义方法"><a href="#转义方法" class="headerlink" title="转义方法"></a>转义方法</h1><p>写这篇文章的时候就发现，要把Markdown语法给端上来还是需要一些操作的，否则这些就会被自动渲染。</p><h2 id="方法一：使用反斜杠"><a href="#方法一：使用反斜杠" class="headerlink" title="方法一：使用反斜杠 \"></a>方法一：使用反斜杠 \</h2><p># &lt;h1&gt; **** </p><h2 id="方法二：使用代码段"><a href="#方法二：使用代码段" class="headerlink" title="方法二：使用代码段 &#96;&#96;"></a>方法二：使用代码段 &#96;&#96;</h2><p><code>&lt;h1&gt;&lt;h2&gt; # **</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;这是一个Markdown语法的速查表&quot;&gt;&lt;a href=&quot;#这是一个Markdown语法的速查表&quot; class=&quot;headerlink&quot; title=&quot;这是一个Markdown语法的速查表&quot;&gt;&lt;/a&gt;这是一个Markdown语法的速查表&lt;/h1&gt;&lt;h1 id=&quot;标</summary>
      
    
    
    
    <category term="Productivity" scheme="http://alphazer01214.github.io/categories/Productivity/"/>
    
    
    <category term="Markdown" scheme="http://alphazer01214.github.io/tags/Markdown/"/>
    
    <category term="LaTeX" scheme="http://alphazer01214.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>有序链表的合并——答案倒推原理</title>
    <link href="http://alphazer01214.github.io/2025/01/13/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6/"/>
    <id>http://alphazer01214.github.io/2025/01/13/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6/</id>
    <published>2025-01-13T03:13:06.000Z</published>
    <updated>2025-01-16T16:40:40.322Z</updated>
    
    <content type="html"><![CDATA[<p><em>该题是LeetCode的第23题</em></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br></pre></td></tr></table></figure><h2 id="思路分析与代码解析"><a href="#思路分析与代码解析" class="headerlink" title="思路分析与代码解析"></a>思路分析与代码解析</h2><p>典型的归并排序问题，在先前的文章中也提到归并排序是如何通过递归来实现的，事实上，归并排序的过程就可以看作是双指针，<br>两个列表逐一遍历，最后变成一个列表。但对于链表，这个过程并不简单，因为链表还有“连接”这一步。<br>我们先端上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *left, ListNode *right)</span></span>&#123;</span><br><span class="line">        ListNode *lptr = left;</span><br><span class="line">        ListNode *rptr = right;</span><br><span class="line">        ListNode *res = <span class="built_in">new</span>(ListNode);</span><br><span class="line">        ListNode *head = res;</span><br><span class="line">        <span class="keyword">while</span>(lptr &amp;&amp; rptr)&#123;</span><br><span class="line">            ListNode *node = <span class="built_in">new</span>(ListNode);</span><br><span class="line">            <span class="keyword">if</span>(lptr-&gt;val &lt; rptr-&gt;val)&#123;</span><br><span class="line">                node-&gt;val = lptr-&gt;val;</span><br><span class="line">                lptr = lptr-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node-&gt;val = rptr-&gt;val;</span><br><span class="line">                rptr = rptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            res-&gt;next = node;</span><br><span class="line">            res = res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lptr == <span class="literal">NULL</span> &amp;&amp; rptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            res-&gt;next = rptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lptr != <span class="literal">NULL</span> &amp;&amp; rptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            res-&gt;next = lptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge_sort</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">merge_sort</span>(lists, left, (left + right)/<span class="number">2</span>), <span class="built_in">merge_sort</span>(lists, (left + right)/<span class="number">2</span> + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge_sort</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先从merge的部分说起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ListNode* merge(ListNode *left, ListNode *right)&#123;</span><br><span class="line">    ListNode *lptr = left;</span><br><span class="line">    ListNode *rptr = right;</span><br><span class="line">    ListNode *res = new(ListNode);</span><br><span class="line">    ListNode *head = res;</span><br><span class="line">    while(lptr &amp;&amp; rptr)&#123;</span><br><span class="line">        ListNode *node = new(ListNode);</span><br><span class="line">        if(lptr-&gt;val &lt; rptr-&gt;val)&#123;</span><br><span class="line">            node-&gt;val = lptr-&gt;val;</span><br><span class="line">            lptr = lptr-&gt;next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            node-&gt;val = rptr-&gt;val;</span><br><span class="line">            rptr = rptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        res-&gt;next = node;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(lptr == NULL &amp;&amp; rptr != NULL)&#123;</span><br><span class="line">        res-&gt;next = rptr;</span><br><span class="line">    &#125;</span><br><span class="line">    if(lptr != NULL &amp;&amp; rptr == NULL)&#123;</span><br><span class="line">        res-&gt;next = lptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步，我们将两个<strong>有序</strong>链表，以它们的头节点作为参数left、right传入了merge函数。</p><p>动用左右指针，逐个遍历，最后得到结果链表，并将这个链表返回。由于使用的是尾插，因此应该返回其头节点的下一节点。</p><p>注意：这个步骤在传入链表均为空链表时依旧是有效的。</p><p>再说说merge_sort这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListNode* merge_sort(vector&lt;ListNode*&gt;&amp; lists, int left, int right)&#123;</span><br><span class="line">    if(left &gt;= right)&#123;</span><br><span class="line">        return lists[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return merge(merge_sort(lists, left, (left + right)/2), merge_sort(lists, (left + right)/2 + 1, right));</span><br></pre></td></tr></table></figure><p>这个函数接受3个参数，其中，lists是一个指针vector，用于存放所有链表的头节点。而left、right则是两个”指针”，这两个参数可以视作对<strong>这些</strong>链表进行切片操作。归并的第一步就是二分的过程，不断二分到left&#x3D;&#x3D;right时，返回lists[left]，如此一来，merge接受了两个头节点参数，合成了一个链表。这一个大链表作为返回值，<strong>是上一级merge_sort中，返回的merge函数的一个参数</strong>，不断向上“并”，实现了链表的合并。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;该题是LeetCode的第23题&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://alphazer01214.github.io/tags/C/"/>
    
    <category term="递归分治" scheme="http://alphazer01214.github.io/tags/%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB/"/>
    
    <category term="LeetCode" scheme="http://alphazer01214.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记——Merge Sort</title>
    <link href="http://alphazer01214.github.io/2025/01/08/Merge-Sort/"/>
    <id>http://alphazer01214.github.io/2025/01/08/Merge-Sort/</id>
    <published>2025-01-08T15:20:36.000Z</published>
    <updated>2025-01-14T15:27:57.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序的主要思想"><a href="#归并排序的主要思想" class="headerlink" title="归并排序的主要思想"></a>归并排序的主要思想</h1><p><strong>归</strong>——将数组分成两部分，分别进行排序。<br><strong>并</strong>——将已经排序的两个数组合并起来。</p><p>“并”的部分对于我而言有点难以理解，接下来的重点会放在“并”上面。</p><h1 id="代码实现——步骤一"><a href="#代码实现——步骤一" class="headerlink" title="代码实现——步骤一"></a>代码实现——步骤一</h1><p>第一步就是使用递归将数组二分，关键在于利用下标实现二分操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">// left right are index</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (right+left)/<span class="number">2</span>;</span><br><span class="line">        merge_sort(arr, left, mid);</span><br><span class="line">        merge_sort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">        msort(arr, left, right, mid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>递归需要终止条件，当长度为1，利用下标表示就是left&gt;&#x3D;right，此时递归结束，返回上一级。<br>接着将二分的索引作为参数（就是新二分出来数组的left，right），进行递归操作，实现原数组的对半分。<br>分割操作之后是msort，稍后讲解。<br>注意：<strong>整个过程中arr本身的长度都是不变的</strong>！而且arr的索引还是从0开始到结束，也就是说，我们并不是真的将数组分割成了一个一个新数组，<strong>我们都是在原数组上进行操作</strong>，我们所有操作都是通过下标实现的。</p><h1 id="代码实现——步骤二"><a href="#代码实现——步骤二" class="headerlink" title="代码实现——步骤二"></a>代码实现——步骤二</h1><p>对于一次并，示意图如下：<br><img src="/../_images/mergesort.png" alt="归并示意图"></p><ol><li>我们假设有两个<strong>已排序</strong>的数组（假设已排序，这样就能先解决将两数组合并的问题）</li><li>这两个数组被拼成了一个数组，下标如图所示</li><li>对这么一个数组进行排序，只需要一次遍历操作<br>我们引入两个类似指针的变量<strong>i, j</strong>，一个指向这个数组的开头，一个指向中间，那么我们就能通过比较<strong>i, j</strong>索引对应的值来进行排序。<br>如果只有这一个数组，排序有些困难，于是我们选择引入新的数组（即复制一遍原数组），然后<strong>把排序结果保存回原数组</strong>。<br>注意：我们这里加入了<strong>left、right、mid</strong>变量来获取这个数组的开头、结尾与中间，其中这三个变量都是索引值。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp_arr[right];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">    <span class="comment">// copy to a temp arr</span></span><br><span class="line">    tmp_arr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = left, j = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = left; k &lt;= right; k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; mid)&#123;</span><br><span class="line">        arr[k] = tmp_arr[j++];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt; right)&#123;</span><br><span class="line">        arr[k] = tmp_arr[i++];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp_arr[i] &lt; tmp_arr[j])&#123;</span><br><span class="line">        arr[k] = tmp_arr[i++];</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(tmp_arr[i] &gt;= tmp_arr[j])&#123;</span><br><span class="line">        arr[k] = tmp_arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h2><p>在自行实现归并排序的过程中，最纠结的就是如何规定数组的长度，但实际上长度并不重要，因为最后都可以按照其索引值将结果复制回原数组。<br>在分成单个数组时，回到了上一步两个数组的状态，而这两个数组长度一定小于等于2，由于msort的过程中一次只能处理一个数组，因此实际上，msort是先分别排序了这两个数组，它们混合进了arr[]，然后再进入msort进行排序。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>在面对元素较少的数组时，可以考虑其它排序方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实我认为“将数组分割再合并”的说法非常令人费解，因为这样就会让人有“把两个数组传进一个函数，这个函数去把这两个数组首尾相接拼起来”的感觉，这种操作如何用递归实现？我还没有探索过。</p><p>实际上可以理解成，含n个元素的一个数组arr，我们先是有n个指针指着各个元素，然后两个两个比较大小&#x2F;对调元素，接下来指针减半（两个指针之间间隔一个位置），然后4个一组，每组有两个指针，进行比大小与对换元素的操作，然后指针再减半，以此类推</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;归并排序的主要思想&quot;&gt;&lt;a href=&quot;#归并排序的主要思想&quot; class=&quot;headerlink&quot; title=&quot;归并排序的主要思想&quot;&gt;&lt;/a&gt;归并排序的主要思想&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;归&lt;/strong&gt;——将数组分成两部分，分别进行排序。&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="Computer Science" scheme="http://alphazer01214.github.io/categories/Computer-Science/"/>
    
    
    <category term="算法" scheme="http://alphazer01214.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Alphazer01214&#39;s First Post</title>
    <link href="http://alphazer01214.github.io/2025/01/08/Alphazer01214-s-First-Post/"/>
    <id>http://alphazer01214.github.io/2025/01/08/Alphazer01214-s-First-Post/</id>
    <published>2025-01-08T13:30:34.000Z</published>
    <updated>2025-01-08T13:52:52.363Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World!</p><p>I created my very first page during my exam week.</p><p>By the way, it’s also my birthday.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hello World!&lt;/p&gt;
&lt;p&gt;I created my very first page during my exam week.&lt;/p&gt;
&lt;p&gt;By the way, it’s also my birthday.&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
